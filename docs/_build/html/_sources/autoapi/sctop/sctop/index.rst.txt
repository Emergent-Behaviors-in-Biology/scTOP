sctop.sctop
===========

.. py:module:: sctop.sctop


Attributes
----------

.. autoapisummary::

   sctop.sctop.BASIS_URLS


Functions
---------

.. autoapisummary::

   sctop.sctop.list_available_bases
   sctop.sctop.load_basis
   sctop.sctop.create_basis
   sctop.sctop.analyze_sample_contributions


Module Contents
---------------

.. py:data:: BASIS_URLS

.. py:function:: list_available_bases() -> sctop.processing.List[str]

   List available premade bases that can be loaded.

   Returns:
   --------
   basis_keys : list
       List of available basis keys


.. py:function:: load_basis(basis_key: str, cache_dir: sctop.processing.Optional[sctop.processing.Union[str, pathlib.Path]] = None, force_download: bool = False) -> sctop.processing.Tuple[sctop.processing.pd.DataFrame, sctop.processing.pd.DataFrame]

   Load a basis from an h5ad file hosted online.

   Parameters:
   -----------
   basis_key : str
       Name/key of the basis to load (e.g., "MCKO legacy")
   cache_dir : str, optional
       Directory to cache downloaded files. If None, uses system temp directory.
   force_download : bool
       If True, re-downloads even if cached file exists

   Returns:
   --------
   basis : pd.DataFrame
       Basis matrix (genes x cell types)
   metadata : pd.DataFrame
       Metadata for the basis (cell types x attributes)

   Example:
   --------
   >>> basis, metadata = load_basis(
   ...     basis_key="MCKO legacy"
   ... )


.. py:function:: create_basis(adata: sctop.utils.ad.AnnData, cell_type_column: str, threshold: int, test_size: float = 0.2, random_state: int = 42, n_jobs: int = -1, do_anova: bool = False, n_features: int = 20000, anova_percentile: sctop.processing.Optional[float] = None, spec_value: float = 0.1, outer_chunks: int = 10, inner_chunk_size: int = 1000, n_scoring_jobs: int = 4, cv_folds: sctop.processing.Optional[int] = None, plot_results: bool = True) -> sctop.utils.Dict

   Create basis and evaluate with optional ANOVA selection and cross-validation.

   Parameters:
   -----------
   adata : ad.AnnData
       Annotated data object
   cell_type_column : str
       Column name for cell types in adata.obs
   threshold : int
       Minimum number of cells per cell type
   test_size : float
       Fraction of data to use for testing (if cv_folds is None)
   random_state : int
       Random seed
   n_jobs : int
       Number of parallel jobs for basis creation
   do_anova : bool
       Whether to perform ANOVA feature selection
   n_features : int
       Number of features to select with ANOVA
   anova_percentile : float, optional
       Percentile of features to keep (overrides n_features)
   spec_value : float
       Threshold for unspecified predictions
   outer_chunks : int
       Number of chunks for parallel scoring
   inner_chunk_size : int
       Chunk size for internal processing
   n_scoring_jobs : int
       Number of parallel jobs for scoring
   cv_folds : int, optional
       Number of cross-validation folds. If None, uses single train-test split

   Returns:
   --------
   results : dict
       Dictionary containing:
       - 'basis': final basis
       - 'selected_genes': selected genes (if ANOVA)
       - 'metrics': performance metrics
       - 'cv_results': cross-validation results (if cv_folds is not None)
       - 'confusion_matrix': confusion matrix
       - 'per_cell_type': per cell type accuracy


.. py:function:: analyze_sample_contributions(sample_data_dict: sctop.utils.Dict[str, sctop.processing.Union[sctop.processing.pd.DataFrame, sctop.processing.np.ndarray]], basis: sctop.processing.pd.DataFrame, cell_types: sctop.processing.Optional[sctop.processing.List[str]] = None, n_top_genes: int = 20, process_data: bool = True) -> sctop.utils.Dict[str, sctop.utils.Dict]

   Analyze gene contributions for multiple samples/clusters.

   :param sample_data_dict: Dictionary mapping sample_name -> expression_data
   :type sample_data_dict: dict
   :param basis: Basis matrix
   :type basis: pd.DataFrame
   :param cell_types: Cell types to analyze. If None, uses all
   :type cell_types: list, optional
   :param n_top_genes: Number of top genes to identify per sample
   :type n_top_genes: int
   :param process_data: Whether to process the data
   :type process_data: bool

   :returns: **results** -- Nested dictionary with structure:
             {cell_type: {
                 'contributions': {sample_name: contribution_matrix},
                 'top_genes': {sample_name: [gene1, gene2, ...]},
                 'expressions': {sample_name: expression_matrix}
             }}
   :rtype: dict


